"""
Take the polyhedra generated by plantri and convert them into tangle form with NW/NE/SW/SE information, which cna be
used to insert tangles.

Example.
Input: "bcde,aedc,abd,acbe,adb"
Output: [(0,'NE',1,'NE'),(0,'NW','v0'),(0,'SW',2,'NE'),(0,'SE','v1'),(1,'NE',0,'NE'),(1,'NW','v1'),(1,'SW',2,'SW'),
(1,'SE','v0'),(0,'NW','v0'),(1,'SE','v0'),(2,'NW','v0'),(2,'NE',0,'SW'),(2,'NW','v0'),(2,'SW',1,'SW'),(2,'SE','v1'),
(0,'SE','v1'),(2,'SE','v1'),(1,'NW','v1')]
"""

from glob import glob
from pathlib import Path
from itertools import product
from collections import defaultdict

import sys

sys.path.append('../..')

import knotpy as kp
from knotpy import insert_tangles_from


poly_dir = Path("./data/1-poly")

def graph_to_empy_tangle(g):
    """Convert a plantri graph to 'empty tangle' notation.
    Example:
    Input: edcb,cdea,dba,ebca,bda
    Output: [(0,'NE','v1'),(0,'NW',2,'SE'),(0,'SW','v0'),(0,'SE',1,'SE'),(1,'NE','v0'),(1,'NW',2,'NW'),(1,'SW','v1'),
             (2,'SW','v0'),(2,'NE','v1')]

    In this example, the node 'a' lies on the arc ('a0', 'e2'), so we add two connections to the output:
    (0,'NE','v1'), since we rename 'e' as a degree 3 vertex 'v1' and 'a' is a degree 4 tangle entry assigned 0.
    """

    compass = {0: "NE", 1: "NW", 2: "SW", 3: "SE"}

    nodes_3 = [v for v in g.nodes if g.degree(v) == 3]  # nodes of degree 3
    nodes_4 = [v for v in g.nodes if g.degree(v) == 4]  # nodes of degree 3

    to_connect = []  # list of doubles, triples or quadruples of connections representing arcs

    for (v, v_pos), (u, u_pos) in g.arcs:
        # swap if vertex before "tangle"
        if v in nodes_3 and u in nodes_4:
            (v, v_pos), (u, u_pos) = (u, u_pos), (v, v_pos)  # tangles before vertices

        cn = []  # connections, where we add either (node index, ordinal direction) or (vertex) to the list
        for w, w_pos in [(v, v_pos), (u, u_pos)]:
            cn += [nodes_4.index(w), compass[w_pos]] if w in nodes_4 else ["v" + str(nodes_3.index(w))]
        to_connect.append(tuple(cn))
    return "".join(str(to_connect).split())


def make_tangle(hvx):
    """Returns new horizontal (H) tangle, vertical (V) or 1-tangle (X)."""
    if hvx == 'H':
        return kp.horizontal_tangle()
    if hvx == 'V':
        return kp.vertical_tangle()
    if hvx == 'X':
        return kp.integer_tangle(1)
    raise ValueError(f"Unknown tangle type {hvx}.")


def tangle_type_collection(g, max_crossings):
    """Gets the tangle types (H, V, X) so that when we insert it to the vertices of the graph g, we get a one component
    spatial graph."""

    nodes_3 = [v for v in g.nodes if g.degree(v) == 3]  # nodes of degree 3
    nodes_4 = [v for v in g.nodes if g.degree(v) == 4]  # nodes of degree 4

    print(len(nodes_3), len(nodes_4))

    all_hvx_seq = ["".join(h) for h in product("HVX", repeat=len(nodes_4))] if len(nodes_4) > 0 else []
    good_hvx = []

    components_stats = defaultdict(int)

    invalid = 0

    for count, hvx_seq in enumerate(all_hvx_seq):

        hv_count = sum(1 for hvx in hvx_seq if hvx != 'X')
        if hv_count > max_crossings - len(nodes_4):
            invalid += 1
            continue



        tangle_seq = [make_tangle(hvx) for hvx in hvx_seq]  # a list of actual Tangles

        result_knot = insert_tangles_from(g, dict(zip(nodes_4, tangle_seq)))

        number_components = kp.number_of_link_components(result_knot)
        components_stats[number_components] += 1  # store number of components

        if number_components < 1:
            raise ValueError()

        if number_components == 1:
            good_hvx.append(hvx_seq)

    print("Stats:", components_stats, "invalid:", invalid)

    #    result = insert_tangles_from(g, )

    return good_hvx

for bonds in range(0,13):
    for filename in glob(str(poly_dir / f"poly-{bonds}-*")):

        print("\n" + filename)
        graphs = kp.loadtxt_multiple(filename, notation="plantri", ccw=True, separator=",")
        tangle_graphs = [graph_to_empy_tangle(g) for g in graphs]

        f = open(filename.replace("poly-", "tang-").replace("1-poly", "2-empty-tangle"), mode="wb")

        f.write(f"# {len(graphs)} tangle graph(s) with HVS tangle information\n".encode("utf-8"))

        #f.write(f"# {len(tangle_graphs)} \"empty tangle\" polyhedra\n".encode("utf-8"))

        for e, g in zip(tangle_graphs, graphs):
            print("  ", g)
            f.write((e + "").encode("utf-8"))
            hvx = tangle_type_collection(g, max_crossings=10)
            print("    ", hvx[:5])
            f.write((" " + str(hvx).replace(" ", "") + "\n").encode("utf-8"))

        f.close()
#    for g, t in zip(graphs[:5], tangle_graphs[:5]):
 #       print(t[:50]+"...")


#g = kp.from_plantri_notation("bcde,aedc,abd,acbe,adb")
#graph_to_empy_tangle(g)

# tangle format
"""
def H41(a,b,c,d):
    clear()
    a,b,c,d = create([a,b,c,d]) 
    reflect([b,d])
    v1,v2 = vertices3(2)
    to_connect = [(a,'NE',v2),(a,'SE',c,'NE'),(a,'SW',b,'SW'),(a,'NW',v1),
                  (b,'NE',d,'SE'),(b,'SE',v1),(b,'NW',c,'NW'),
                  (c,'SE',v2),(c,'SW',d,'SW'),
                  (d,'NE',v1),(d,'NW',v2)]
    connect(to_connect)
    direct()
    pd = PDcode()
    return pd


"""

