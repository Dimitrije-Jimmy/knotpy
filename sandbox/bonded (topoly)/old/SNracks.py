#from sympy import *

####################################################
# Report Bugs to Sam.Nelson@cmc.edu
# Updated 10.8.2011
####################################################

#######################
# Quandles and Racks
#######################


def racktest(M):   
    ### Test whether M is a rack matrix ###
    q = True
    for i in range(1,len(M)+1):
        c = []
        for j in range(1,len(M)+1):
            for k in range(1,len(M)+1):
                if M[M[i-1][j-1]-1][k-1]!=M[M[i-1][k-1]-1][M[j-1][k-1]-1]:
                    q = False
                    break
            c = c + [M[j-1][i-1]]
        if not permtest(c):
            q = False
            break
    return q


def quandletest(M):   
    ### Test whether M is quandle matrix ###
    q = True
    for i in range(1,len(M)+1):
        if M[i-1][i-1] != i:
            q = False
            break
        c = []
        for j in range(1,len(M)+1):
            for k in range(1,len(M)+1):
                if M[M[i-1][j-1]-1][k-1]!=M[M[i-1][k-1]-1][M[j-1][k-1]-1]:
                    q = False
                    break
            c = c + [M[j-1][i-1]]
        if not permtest(c):
            q = False
            break
    return q


def subrack(L,M):
    ### find subrack of M generated by L ###
    out = []
    for x in L:
        if not x in out:
            out.append(x)
    c = True
    while c:
        c = False
        for x in out:
            for y in out:
                z = M[x-1][y-1]
                if not z in out:
                    out.append(z)
                    c = True
    return out 



def isotest(M,N):
    ### Test whether M is isomorphic to N ###
    z = []
    for i in range(1,len(M)+1):
        z = z + [0]
    L = [z]
    out = []
    while len(L) != 0 and len(out) == 0:
        w = L[0]
        L[0:1] = []  
        if w:
            i = hfindzero(w)
            if not i:
                if permtest(w): out.append(w)
            else:
                for j in pavail(w):
                    phi = list(w)
                    phi[i-1] = j
                    v = homfill(M,N,phi)
                    if v: L.append(tuple(v))
    if len(out) == 0:
        return False
    else:
        return True    
     

def reducelist(L):
    ### Remove isomorphic copies from L ###
    out = [tm(L[0])]
    W = L
    while len(W)>0:
        x = W[0]
        W[0:1] = []
        newrack = True
        for y in out:
            if isotest(x,y): newrack = False
        if newrack: out.append(tm(x))
    return out



def homlist(M,N):   
    ###Lists homomorphisms f:M->N###
    z = []
    for i in range(1,len(M)+1):
        z = z + [0]
    L = [z]
    out = []
    while len(L) != 0:
        w = L[0]
        L[0:1] = []  
        if w:
            i = hfindzero(w)
            if not i:
                out.append(w)
            else:
                for j in range(1,len(N)+1):
                    phi = list(w)
                    phi[i-1] = j
                    v = homfill(M,N,phi)
                    if v: L.append(tuple(v))
    return out     



def homfill(M,N,phi):   
    ### Fills in entries in a homomorphism ###
    f = phi
    c = True
    out = True
    while c == True:
        c = False
        for i in range(1,len(M)+1):
            for j in range(1,len(M)+1):
                if f[i-1] !=0 and f[j-1] != 0:
                    if f[M[i-1][j-1]-1] == 0 and M[i-1][j-1] != 0:
                       f[M[i-1][j-1]-1] = N[f[i-1]-1][f[j-1]-1]
                       c = True
                    elif f[M[i-1][j-1]-1] != 0 and f[M[i-1][j-1]-1] != N[f[i-1]-1][f[j-1]-1]:
                       out = False
                       c = False
    if out == True: 
       return f
    else:
       return out


def hfindzero(f):   
    ### find zero in homomorphism template ###
    j = -1
    for i in range(0,len(f)):
        if f[i] == 0: 
            j = i+1
            break
    if j < 0: out = False
    else: out = j
    return out


def rackrank(M):
    ### find rack rank ###
    rr = []
    for i in range(1,len(M)+1):
        c = 1
        j = M[i-1][i-1]
        while j != i:
            c = c+1
            j = M[j-1][j-1]
        rr.append(c)
    out = 1
    for x in rr:
        out = lcm(out,x)
    return out


########################
# Generating racks
########################


def reptest(p):   
    ### Test whether p has repeated non-zero entries ###
    q = True
    L = []
    for i in range(1,len(p)+1):
        if p[i-1] != 0:
            if p[i-1] in L:
                q = False
            else:
                L.append(p[i-1])
    return q



def sdfill(N):
    ### fill with self-distributiviity ###
    c = True
    con = False
    M = lm(N)
    while c:
        c = False
        for i in range(1,len(M)+1):
            for j in range(1,len(M)+1):
                for k in range(1,len(M)+1):
                    if M[i-1][j-1] != 0 and M[M[i-1][j-1]-1][k-1] != 0:
                        if M[i-1][k-1] != 0 and M[j-1][k-1] != 0:
                            if M[M[i-1][j-1]-1][k-1] != M[M[i-1][k-1]-1][M[j-1][k-1]-1]:
                                if M[M[i-1][j-1]-1][k-1] == 0:
                                    M[M[i-1][j-1]-1][k-1] = M[M[i-1][k-1]-1][M[j-1][k-1]-1]
                                    c = True
                                elif M[M[i-1][k-1]-1][M[j-1][k-1]-1] == 0:
                                    M[M[i-1][k-1]-1][M[j-1][k-1]-1] = M[M[i-1][j-1]-1][k-1]
                                    c = True
                                else:
                                    con = True
    if con: M = False
    return M
     


def findzero(M):
    ### Find position of first zero entry in a matrix ###
    out = False
    for i in range(1,len(M)+1):
        if not out:
            for j in range(1,len(M[0])+1):
                if M[i-1][j-1] == 0:
                    out = (i,j)
                    break
    return out



def pavail(v):
    ### List available entries ###
    L = []
    for i in range(1,len(v)+1):
        if not i in v: L.append(i)
    return tuple(L)



def racklist(N):
    ### find all racks matching pattern ###
    L = []
    L.append(tm(N))
    out = []
    while len(L)>0:
       M = L[0]
       L[0:1] = []
       q = findzero(M)
       if q:
           for i in pavail(getcolumn(M,q[1])):
               M2 = lm(M)
               M2[q[0]-1][q[1]-1] = i
               M3 = sdfill(M2)
               if M3:
                    col = True 
                    for j in range(1,len(M)+1):
                        if not reptest(getcolumn(M3,j)):
                            col = False
                    if col:  L.append(tm(M3))
       else:
           out.append(tuple(M))
    return out


def rackaut(M):
    out = []
    for x in homlist(M,M):
        if permtest(x): out.append(x)
    return out

def permtest(M):
    c =[]
    for i in range(1,len(M)+1):
        c.append(i)
    for j in range(1,len(M)+1):
        if j in M:
            M.remove(c[j-1])
    return len(M) == 0


################################
# Mod n linear algebra stuff
###############################

def getcolumn(M,j):   # get column n from matrix M
    ### Gets column n from matrix M### 
    c =[]
    for i in range(1,len(M)+1):
        c.append(M[i-1][j-1])
    return c



def tm(M):
    ### tuple matrix### 
    out  = []
    for x in M: out.append(tuple(x))
    return tuple(out)



def lm(M):
    ### list matrix### 
    out = []
    for x in M: out.append(list(x))
    return list(out)



def mtranspose(M):
    ### transpose matrix### 
    out=[]
    for i in range(1,len(M[0])+1):
        r = []
        for j in range(1,len(M)+1):
            r.append(M[j-1][i-1])
        out.append(r)
    return out


